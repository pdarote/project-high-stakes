# Go Project Guidelines

## 📚 Overview
This document outlines the project structure, naming conventions, and best practices for developing a Go project using the Echo framework. The guidelines will help ensure consistency across the codebase and make it easier for GitHub Copilot to generate high-quality code that adheres to the project standards.

---

## 📁 Project Structure

The project should follow a best-practice structure as shown below:

```plaintext
go-folder/
├── cmd/                 # Command-line applications (entry point)
│   └── server.go        # Main application entry point
├── internal/            # Internal packages (not exported outside the module)
│   ├── handlers/        # HTTP request handlers
│   ├── models/          # Data models
│   ├── services/        # Business logic
│   └── docs/            # Swagger documentation
├── pkg/                 # Public packages (shared, reusable code)
├── config/              # Configuration files
├── Dockerfile           # Docker configuration for containerizing the app
├── docker-compose.yml   # Docker Compose setup for running the app with dependencies
├── go.mod               # Go module file
└── swagger.yaml         # Swagger/OpenAPI specification
```

### 🔧 **Directory Descriptions:**
- **`cmd/`**: Contains the main entry point for the application.
- **`internal/`**: Contains application-specific code that should not be accessible outside the module.
  - **`handlers/`**: Contains HTTP request handlers for various routes.
  - **`models/`**: Contains data models representing the structure of data.
  - **`services/`**: Contains business logic and service functions.
  - **`docs/`**: Contains Swagger YAML or JSON files, autogenerated documentation files, or related assets.
- **`pkg/`**: Contains reusable packages that can be shared across multiple projects.
- **`config/`**: Contains configuration files such as environment variables.
- **`Dockerfile`**: Docker configuration file for containerizing the application.
- **`docker-compose.yml`**: Docker Compose file for managing multi-container setups.
- **`swagger.yaml`**: Swagger/OpenAPI specification for documenting API endpoints.

---

## 📝 Naming Conventions

1. **Files and Folders**  
   - Use **snake_case** for all file and folder names (e.g., `user_service.go`, `todo_handler.go`).

2. **Packages**  
   - Use **lowercase** for package names.  
   - Avoid underscores or hyphens in package names.

3. **Functions and Variables**  
   - Use **camelCase** for function and variable names (e.g., `getUser`, `createTodo`).

4. **Constants**  
   - Use **ALL_CAPS** with underscores for constants (e.g., `MAX_RETRIES`).

5. **Interfaces**  
   - Use descriptive names ending with `er` (e.g., `Reader`, `Writer`, `TodoManager`).

---

## 🛠 Best Practices

1. **Use Dependency Injection**  
   - Pass dependencies (like services) into handlers and avoid global variables.

2. **Handle Errors Gracefully**  
   - Return detailed error messages and use Go’s built-in error handling.

3. **Write Unit Tests**  
   - Ensure all handlers and services have corresponding unit tests.

4. **Follow RESTful Principles**  
   - Use standard HTTP methods (GET, POST, PUT, DELETE) and status codes.

5. **Use Environment Variables for Configuration**  
   - Store sensitive information like API keys in environment variables.

6. **Document APIs with Swagger**  
   - All APIs must include detailed Swagger documentation.  
   - Use annotations in your Go code to generate Swagger docs automatically.

---

## 🌐 Example File: `server.go`

```go
package main

import (
    "log"
    "os"

    "github.com/labstack/echo/v4"
    "github.com/swaggo/echo-swagger" // Swagger middleware
    _ "project-name/internal/docs"    // Import for Swagger documentation generation
)

func main() {
    // Create a new Echo instance
    e := echo.New()

    // Swagger endpoint
    e.GET("/swagger/*", echoSwagger.WrapHandler)

    // Define a simple route
    e.GET("/", func(c echo.Context) error {
        return c.String(200, "Hello, World!")
    })

    // Start the server
    port := os.Getenv("PORT")
    if port == "" {
        port = "8080"
    }

    log.Printf("Starting server on port %s", port)
    e.Logger.Fatal(e.Start(":" + port))
}
```

---

## 📜 Swagger Integration

1. **Add Swagger Annotations**
   - Use comments in your Go code to define Swagger metadata.

2. **Example Handler with Swagger Comments**
   ```go
   package handlers

   import (
       "net/http"

       "github.com/labstack/echo/v4"
   )

   // CreateTodo godoc
   // @Summary Create a new todo
   // @Description Create a new todo with a title and description
   // @Tags todos
   // @Accept json
   // @Produce json
   // @Param todo body models.Todo true "Todo to create"
   // @Success 201 {object} models.Todo
   // @Failure 400 {object} echo.HTTPError
   // @Router /todos [post]
   func CreateTodoHandler(c echo.Context) error {
       // Handler logic here
       return c.JSON(http.StatusCreated, "Todo created")
   }
   ```

3. **Generate Swagger Documentation**
   - Install `swaggo`:
     ```bash
     go install github.com/swaggo/swag/cmd/swag@latest
     ```
   - Generate Swagger docs:
     ```bash
     swag init -g cmd/server.go -o internal/docs
     ```
   - This command generates Swagger files in the `internal/docs` directory.

4. **Serve Swagger UI**
   - Add the following route in your server setup:
     ```go
     e.GET("/swagger/*", echoSwagger.WrapHandler)
     ```

---

## 🧪 Unit Testing Guidelines

1. **Test Files**  
   - Place test files in the same directory as the code they are testing.  
   - Use the `_test.go` suffix for test files (e.g., `todo_service_test.go`).

2. **Testing Package**  
   - Use Go’s built-in `testing` package.

3. **Table-Driven Tests**  
   - Use table-driven tests to make your tests more readable and maintainable.

---

## 📂 Example Test File: `todo_service_test.go`

```go
package services

import (
    "testing"

    "github.com/stretchr/testify/assert"
)

func TestCreateTodo(t *testing.T) {
    tests := []struct {
        name     string
        input    string
        expected string
    }{
        {"Valid Input", "Buy milk", "Todo created: Buy milk"},
        {"Empty Input", "", "Todo cannot be empty"},
    }

    for _, test := range tests {
        t.Run(test.name, func(t *testing.T) {
            result := CreateTodo(test.input)
            assert.Equal(t, test.expected, result)
        })
    }
}
```